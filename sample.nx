// let fib = fn n ->
//   if n <= 1
//     ret n
//   else
//     ret (fib(n-1) + fib(n-2))

// let start = clock()
// print "Let's calculate fib(35)!"
// let result = fib(35)
// print clock() - start

// print result

// let outer = fn -> {
//   let x = "outside"
//   let inner = fn -> {
//     print x
//   }
//   inner()
// }
// outer()

// fn closure -> outer()

// closure()

for let i = 0 ; i < 100 ; i = i + 1 {
  let outer = fn -> {
    let x = "outside"
    let inner = fn -> {
      print x
    }
    ret inner;
  }

  for let y = 0; y < 100; y = y + 1 {
    let x = fn -> {
      print "Hello World"
    }
    x()
  }
  let closure = outer()
  closure()
  print i
}

// TODO: Add support for pure objs

// TODO: Add support for sequences

// [] + "Strtoseq" = ["S", "t", "r", "t", "o", "s", "e", "q"]
// [] // <- Seq
// [1,2,3] + [4,5,6] = [1,2,3,4,5,6]
// [1,2,3] + 4 = [1,2,3,4]

// let u = [1,2,3] each(print) map(fn x -> x = x+1) tap(let x) map(fn x -> x = x+1)

// let i = match [1,2,3] {
//   [1,2,3] -> "In match context, we don't really compare references",
//   [_,2,3] -> "Don't care about the first value, but it is followed by 2,3",
//   [_,2,...] -> "Don't care about the first value, but it is followed by 2..",
//   [@bool, @str, @obj, @fn, @num] -> "We can match on types",
//   [...] -> {
//     print "We can match on sequences of any length"
//     ret "We can also return from match blocks"
//   }
//   some(fn x -> (x / 2) % 2 == 0) -> "Some element is even",
//   some(1) -> "Some element is 1",
//   every(1 or 2 or 3) -> "Every element is 1, 2 or 3",
//   every(@num) -> "Every element is a number",
//   some(@str) -> "Some element is a string",
//   _ -> "Default case"
// }


